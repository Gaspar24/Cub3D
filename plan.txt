// includes/cub3d.h

#ifndef CUB3D_H
#define CUB3D_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "minilibx-linux/mlx.h"

typedef struct s_texture {
    char *north;
    char *south;
    char *west;
    char *east;
    int floor_color;
    int ceiling_color;
} t_texture;

typedef struct s_map {
    char **map;
    int width;
    int height;
} t_map;

typedef struct s_game {
    t_texture texture;
    t_map map;
    // Add more fields as needed
} t_game;

void parse_map(char *file, t_game *game);

#endif
Helper Functions
Implement helper functions to handle file reading and string manipulation.

c
Copy code
// srcs/utils.c

#include "cub3d.h"

char *read_file(const char *filename) {
    int fd = open(filename, O_RDONLY);
    if (fd < 0) {
        perror("Error opening file");
        exit(EXIT_FAILURE);
    }
    char buffer[1024];
    char *content = malloc(1);
    content[0] = '\0';
    int bytes_read;
    while ((bytes_read = read(fd, buffer, sizeof(buffer) - 1)) > 0) {
        buffer[bytes_read] = '\0';
        content = realloc(content, strlen(content) + bytes_read + 1);
        strcat(content, buffer);
    }
    close(fd);
    return content;
}

char **split_string(const char *str, char delimiter) {
    char **result = malloc(sizeof(char *) * 100); // Adjust size as needed
    int count = 0;
    char *token;
    char *str_copy = strdup(str);
    while ((token = strsep(&str_copy, &delimiter)) != NULL) {
        result[count++] = strdup(token);
    }
    result[count] = NULL;
    free(str_copy);
    return result;
}

int parse_color(const char *str) {
    int r, g, b;
    if (sscanf(str, "%d,%d,%d", &r, &g, &b) != 3) {
        fprintf(stderr, "Error: Invalid color format\n");
        exit(EXIT_FAILURE);
    }
    return (r << 16) | (g << 8) | b;
}
Parse the Map File
Implement the main parsing function to handle the .cub file format.

c
Copy code
// srcs/parse_map.c

#include "cub3d.h"

void parse_textures(char **lines, t_texture *texture) {
    for (int i = 0; lines[i]; i++) {
        if (strncmp(lines[i], "NO ", 3) == 0)
            texture->north = strdup(lines[i] + 3);
        else if (strncmp(lines[i], "SO ", 3) == 0)
            texture->south = strdup(lines[i] + 3);
        else if (strncmp(lines[i], "WE ", 3) == 0)
            texture->west = strdup(lines[i] + 3);
        else if (strncmp(lines[i], "EA ", 3) == 0)
            texture->east = strdup(lines[i] + 3);
        else if (strncmp(lines[i], "F ", 2) == 0)
            texture->floor_color = parse_color(lines[i] + 2);
        else if (strncmp(lines[i], "C ", 2) == 0)
            texture->ceiling_color = parse_color(lines[i] + 2);
    }
}

void parse_map_content(char **lines, t_map *map) {
    int start = 0;
    while (lines[start] && (lines[start][0] < '0' || lines[start][0] > '1'))
        start++;
    map->height = 0;
    for (int i = start; lines[i]; i++, map->height++)
        map->width = strlen(lines[i]) > map->width ? strlen(lines[i]) : map->width;
    map->map = malloc(sizeof(char *) * (map->height + 1));
    for (int i = 0; i < map->height; i++)
        map->map[i] = strdup(lines[start + i]);
    map->map[map->height] = NULL;
}

void parse_map(char *file, t_game *game) {
    char *content = read_file(file);
    char **lines = split_string(content, '\n');
    parse_textures(lines, &game->texture);
    parse_map_content(lines, &game->map);
    free(content);
    for (int i = 0; lines[i]; i++)
        free(lines[i]);
    free(lines);
}
Update Main Function
Update your main.c to use the parsing function.

c
Copy code
// srcs/main.c

#include "cub3d.h"

int main(int argc, char **argv) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <map.cub>\n", argv[0]);
        return 1;
    }

    t_game game;
    memset(&game, 0, sizeof(t_game)); // Initialize game structure

    parse_map(argv[1], &game);

    // Initialize window and start the game loop
    t_window win;
    init_window(&win);
    mlx_loop(win.mlx_ptr);

    // Free allocated resources
    free(game.texture.north);
    free(game.texture.south);
    free(game.texture.west);
    free(game.texture.east);
    for (int i = 0; game.map.map[i]; i++)
        free(game.map.map[i]);
    free(game.map.map);

    return 0;
}
Summary
Read and Split the File: Read the .cub file and split it into lines.
Parse Textures and Colors: Identify and store texture paths and colors.
Parse Map Content: Extract and store the map layout.
Main Function: Update the main function to utilize the parsing functions and initialize the game.


------------------------------------------------------------------------------------


#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <errno.h>

typedef struct s_config {
    char *north_texture;
    char *south_texture;
    char *west_texture;
    char *east_texture;
    int floor_color[3];
    int ceiling_color[3];
} t_config;

// 2. Utility Functions

// Implement basic utility functions to help with parsing:

//     String Comparison and Copying: Implement your own versions of strncmp and strdup since you can't use them directly.

// c

int ft_strncmp(const char *s1, const char *s2, size_t n) {
    while (n && *s1 && (*s1 == *s2)) {
        s1++;
        s2++;
        n--;
    }
    if (n == 0) return 0;
    return *(unsigned char *)s1 - *(unsigned char *)s2;
}

char *ft_strdup(const char *s1) {
    size_t len = 0;
    while (s1[len])
        len++;
    char *copy = malloc(len + 1);
    if (!copy)
        return NULL;
    for (size_t i = 0; i < len; i++)
        copy[i] = s1[i];
    copy[len] = '\0';
    return copy;
}

void exit_with_error(const char *message) {
    write(2, "Error\n", 6);
    write(2, message, strlen(message));
    write(2, "\n", 1);
    exit(EXIT_FAILURE);
}

//     Parsing RGB Colors: Implement a function to parse RGB values from a string:

// c

void parse_rgb(const char *line, int *color) {
    int i = 0, value = 0, count = 0;

    while (line[i]) {
        if (line[i] >= '0' && line[i] <= '9') {
            value = value * 10 + (line[i] - '0');
        } else if (line[i] == ',' || line[i] == '\0') {
            if (count < 3) {
                color[count++] = value;
                value = 0;
            }
            if (line[i] == '\0')
                break;
        } else {
            exit_with_error("Invalid RGB format");
        }
        i++;
    }
    if (count != 3)
        exit_with_error("Incomplete RGB color value");
    for (i = 0; i < 3; i++) {
        if (color[i] < 0 || color[i] > 255)
            exit_with_error("RGB value out of range");
    }
}

// 3. Parsing Configuration

// Implement a function to read and parse the configuration data from the file:

// c

void parse_line(char *line, t_config *config) {
    if (ft_strncmp(line, "NO ", 3) == 0) {
        config->north_texture = ft_strdup(line + 3);
    } else if (ft_strncmp(line, "SO ", 3) == 0) {
        config->south_texture = ft_strdup(line + 3);
    } else if (ft_strncmp(line, "WE ", 3) == 0) {
        config->west_texture = ft_strdup(line + 3);
    } else if (ft_strncmp(line, "EA ", 3) == 0) {
        config->east_texture = ft_strdup(line + 3);
    } else if (ft_strncmp(line, "F ", 2) == 0) {
        parse_rgb(line + 2, config->floor_color);
    } else if (ft_strncmp(line, "C ", 2) == 0) {
        parse_rgb(line + 2, config->ceiling_color);
    } else if (line[0] == '1') {
        // This marks the beginning of the map, stop parsing config
        return;
    } else {
        exit_with_error("Invalid configuration line");
    }
}

// 4. Main Function for Reading the File

// Since we cannot use fgets, we'll read the file using read in chunks and parse it line by line:

// c

#define BUFFER_SIZE 4096

void read_file(const char *filename, t_config *config) {
    int fd = open(filename, O_RDONLY);
    if (fd < 0) {
        perror("Error opening file");
        exit(EXIT_FAILURE);
    }

    char buffer[BUFFER_SIZE];
    int bytes_read;
    char line[256];
    int line_len = 0;

    while ((bytes_read = read(fd, buffer, BUFFER_SIZE)) > 0) {
        for (int i = 0; i < bytes_read; i++) {
            if (buffer[i] == '\n') {
                line[line_len] = '\0';
                parse_line(line, config);
                line_len = 0;
            } else {
                line[line_len++] = buffer[i];
            }
        }
    }

    if (bytes_read < 0) {
        perror("Error reading file");
        close(fd);
        exit(EXIT_FAILURE);
    }

    close(fd);
}

int main(int argc, char **argv) {
    if (argc != 2) {
        write(2, "Usage: ./parser <path_to_cub_file>\n", 35);
        return EXIT_FAILURE;
    }

    t_config config = {0}; // Initialize the config structure

    read_file(argv[1], &config);

    // Print parsed information (for testing)
    printf("North Texture: %s\n", config.north_texture);
    printf("South Texture: %s\n", config.south_texture);
    printf("West Texture: %s\n", config.west_texture);
    printf("East Texture: %s\n", config.east_texture);
    printf("Floor Color: %d,%d,%d\n", config.floor_color[0], config.floor_color[1], config.floor_color[2]);
    printf("Ceiling Color: %d,%d,%d\n", config.ceiling_color[0], config.ceiling_color[1], config.ceiling_color[2]);

    // Free allocated memory
    free(config.north_texture);
    free(config.south_texture);
    free(config.west_texture);
    free(config.east_texture);

    return 0;
}


---------------------------------------------------------------------------------

Project Plan for cub3D:

Creating a "realistic" 3D graphical representation using ray-casting is a challenging but exciting project. Below is a structured plan to help you tackle this project, including steps for setting up the project, parsing the map, and integrating the MiniLibX library.
1. Project Setup

Directory Structure:

bash

cub3D/
├── Makefile
├── src/
│   ├── main.c
│   ├── init.c
│   ├── render.c
│   ├── raycasting.c
│   ├── input_handling.c
│   ├── map_parsing.c
│   ├── texture_loading.c
│   ├── utils.c
├── include/
│   ├── cub3d.h
│   ├── mlx.h
│   ├── keys.h
├── assets/
│   ├── north_texture.xpm
│   ├── south_texture.xpm
│   ├── east_texture.xpm
│   ├── west_texture.xpm
├── maps/
│   ├── example.cub
└── libft/
    └── [Libft files]

2. Makefile

Your Makefile should handle the following:

    all: Compile the project
    clean: Remove object files
    fclean: Remove all compiled files, including the executable
    re: Clean and rebuild the project
    bonus: Build any bonus features (if implemented)

Example Makefile:

Makefile

NAME = cub3D
CC = gcc
CFLAGS = -Wall -Wextra -Werror -Iinclude -Ilibft -I/usr/include
LIBFT = libft/libft.a
MLX = -lmlx -framework OpenGL -framework AppKit

SRCS = src/main.c src/init.c src/render.c src/raycasting.c src/input_handling.c \
       src/map_parsing.c src/texture_loading.c src/utils.c
OBJS = $(SRCS:.c=.o)

all: $(NAME)

$(NAME): $(OBJS) $(LIBFT)
	$(CC) $(CFLAGS) $(OBJS) $(LIBFT) $(MLX) -o $(NAME)

$(LIBFT):
	make -C libft

clean:
	rm -f $(OBJS)
	make clean -C libft

fclean: clean
	rm -f $(NAME)
	make fclean -C libft

re: fclean all

bonus:
	# Add bonus compilation rules here if needed

.PHONY: all clean fclean re bonus

3. Understanding Ray-Casting

Ray-casting is the core technique you'll use to render a 3D perspective from a 2D map. The idea is to cast rays from the player's point of view, detect the distance to the nearest wall, and render vertical lines accordingly.

Key Concepts:

    Ray Direction: Determine the direction each ray is cast.
    Wall Collision Detection: Detect where the ray hits a wall.
    Projection: Convert the 3D distance to 2D screen height for walls.
    Texturing: Apply wall textures based on the side the ray hits.

4. Parsing the .cub File

You'll need to create a parser that can read and interpret the .cub file format.

Steps to Parse the Map:

    File Reading:
        Open the file and read its contents line by line.
        Use the get_next_line function from your libft to handle the reading.

    Parsing Identifiers:
        Identify and store paths for textures (NO, SO, WE, EA).
        Parse and store floor (F) and ceiling (C) colors.

    Parsing the Map:
        The map should only contain characters 0, 1, N, S, E, W.
        Validate that the map is closed/surrounded by walls (1).
        Store the map in a 2D array or a suitable data structure.

    Error Handling:
        If there are issues (e.g., the map is not closed or invalid characters), print Error\n followed by a descriptive error message and exit.

Example map_parsing.c:

c

#include "cub3d.h"

void parse_map(char *file_path, t_game *game)
{
    int fd;
    char *line;

    fd = open(file_path, O_RDONLY);
    if (fd < 0)
        exit_with_error("Error\nFailed to open map file.");

    while (get_next_line(fd, &line) > 0)
    {
        // Parse each line based on its identifier (NO, SO, WE, EA, F, C, or map data)
        // For example:
        if (ft_strncmp(line, "NO", 2) == 0)
            game->textures[NO] = parse_texture(line);
        else if (ft_strncmp(line, "F", 1) == 0)
            game->floor_color = parse_color(line);
        else if (ft_isdigit(line[0]))
            parse_map_line(line, game);
        free(line);
    }
    close(fd);
}

5. Initializing the Game (init.c)

Before you start rendering, you need to initialize various components of your game, such as loading textures, setting up the initial player position, and configuring the MiniLibX window.

Example init.c:

c

#include "cub3d.h"

void init_game(t_game *game)
{
    // Initialize the MiniLibX library
    game->mlx = mlx_init();
    if (!game->mlx)
        exit_with_error("Error\nFailed to initialize MLX.");

    // Load textures
    load_textures(game);

    // Initialize player position and direction
    init_player(game);
}

6. Rendering the Scene (render.c)

The main rendering loop will:

    Clear the screen.
    Cast rays to determine what to draw.
    Draw walls, ceiling, and floor based on the ray-casting results.
    Handle input for player movement and view changes.

Example render.c:

c

#include "cub3d.h"

void render(t_game *game)
{
    // Clear the previous frame
    mlx_clear_window(game->mlx, game->win);

    // Ray-casting to render the scene
    for (int x = 0; x < SCREEN_WIDTH; x++)
        cast_ray(game, x);

    // Display the frame
    mlx_put_image_to_window(game->mlx, game->win, game->img, 0, 0);
}

7. Handling Input (input_handling.c)

Handle keyboard input to move the player around the maze and look left or right.

Example input_handling.c:

c

#include "cub3d.h"

int handle_keypress(int keycode, t_game *game)
{
    if (keycode == ESC_KEY)
        exit_game(game);
    else if (keycode == W_KEY)
        move_forward(game);
    else if (keycode == S_KEY)
        move_backward(game);
    else if (keycode == A_KEY)
        move_left(game);
    else if (keycode == D_KEY)
        move_right(game);
    else if (keycode == LEFT_ARROW)
        rotate_left(game);
    else if (keycode == RIGHT_ARROW)
        rotate_right(game);

    return (0);
}

8. Using MiniLibX

MiniLibX provides the tools to create a window, handle events, and manipulate images:

    Window Management: Create and manage the game window.
    Image Handling: Create and manipulate images, which are essential for rendering textures.
    Event Handling: Capture and respond to user input.

9. Testing & Debugging

Regularly test your application with different .cub files to ensure that:

    The map is parsed correctly.
    The ray-casting renders the scene as expected.
    User inputs are handled smoothly.
    Errors are reported accurately.

10. Optimization

After getting everything to work, consider optimizing the code for performance, especially the ray-casting loop, as it can be resource-intensive.
11. Bonus Features (Optional)

If you have time, consider adding extra features like:

    Additional textures.
    More complex map parsing with multiple levels.
    A minimap.
    Sound effects using an audio library.

