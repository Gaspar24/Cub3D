
// ---------------------------tutorial test--------------------

// ----------Global vars---------


// int map_width = 16;
// int map_height = 16;
// char map[16][16] = {
//     "1111111111111111",
//     "1000000000000001",
//     "1000000000000001",
//     "1000000000000001",
//     "1000000000000001",
//     "1000000000000001",
//     "1000000000000001",
//     "1000000000000001",
//     "1000000000000001",
//     "1000000000000001",
//     "1000000000000001",
//     "1000000000000001",
//     "1000000000000001",
//     "1000000000000001",
//     "1000000000000001",
//     "1111111111111111"
// };

// float fPlayerX = 8.0f; // Start position in the middle of the map
// float fPlayerY = 8.0f; // Start position in the middle of the map
// float fPlayerA = 0.0f; // Initial view angle
// int screen_width = 1280;
// int screen_height = 720;

// float fov = 3.14159f / 4.0f;
// float depth = 16.0f;

// // Movement parameters
// int key_states[256] = {0}; // Array to track which keys are pressed

// // typedef struct s_mlx {
// //     void    *mlx_p;
// //     void    *window;
// //     struct {
// //         void *img;
// //         char *addr;
// //         int bits_per_pixel;
// //         int line_length;
// //         int endian;
// //     } img;
// // } t_mlx;

// // Function to track key press events
// int key_press(int keycode, t_mlx *mlx) {
//     key_states[keycode] = 1; // Set key as pressed
//     return 0;
// }

// // Function to track key release events
// int key_release(int keycode, t_mlx *mlx) {
//     key_states[keycode] = 0; // Set key as released
//     return 0;
// }

// // Function to update player movement based on pressed keys
// void update_player_movement() {
//     float move_speed = 0.1f;
//     float rotate_speed = 0.1f;

//     if (key_states[13]) { // W: Move forward
//         fPlayerX += cosf(fPlayerA) * move_speed;
//         fPlayerY += sinf(fPlayerA) * move_speed;
//     }
//     if (key_states[1]) { // S: Move backward
//         fPlayerX -= cosf(fPlayerA) * move_speed;
//         fPlayerY -= sinf(fPlayerA) * move_speed;
//     }
//     if (key_states[0]) { // A: Strafe left
//         fPlayerX += cosf(fPlayerA - 3.14159f / 2) * move_speed;
//         fPlayerY += sinf(fPlayerA - 3.14159f / 2) * move_speed;
//     }
//     if (key_states[2]) { // D: Strafe right
//         fPlayerX += cosf(fPlayerA + 3.14159f / 2) * move_speed;
//         fPlayerY += sinf(fPlayerA + 3.14159f / 2) * move_speed;
//     }
//     if (key_states[123]) { // Left arrow: Rotate left
//         fPlayerA -= rotate_speed;
//     }
//     if (key_states[124]) { // Right arrow: Rotate right
//         fPlayerA += rotate_speed;
//     }
// }

// // Helper function to put pixel
// void my_mlx_pixel_put(t_mlx *mlx, int x, int y, int color) {
//     char *dst;
//     dst = mlx->img.addr + (y * mlx->img.line_length + x * (mlx->img.bits_per_pixel / 8));
//     *(unsigned int *)dst = color;
// }

// // Game loop function
// void game_loop(t_data *data, t_mlx *mlx) {
//     // Initialize mlx and create window first
//     mlx->mlx_p = mlx_init();
//     mlx->window = mlx_new_window(mlx->mlx_p, screen_width, screen_height, "Maze Runner");

//     // Create image after initializing mlx
//     mlx->img.img = mlx_new_image(mlx->mlx_p, screen_width, screen_height);
//     mlx->img.addr = mlx_get_data_addr(mlx->img.img, &mlx->img.bits_per_pixel, &mlx->img.line_length, &mlx->img.endian);

//     // Hook for key press and release
//     mlx_hook(mlx->window, 2, 1L<<0, key_press, mlx);    // Key press
//     mlx_hook(mlx->window, 3, 1L<<1, key_release, mlx);  // Key release

//     // Main rendering loop
//     while (1) {
//         // Update player movement based on keys pressed
//         update_player_movement();

//         // Clear the image by re-rendering the scene
//         for (int x = 0; x < screen_width; x++) {
//             // Calculate the ray angle
//             float ray_angle = (fPlayerA - fov / 2.0f) + ((float)x / (float)screen_width) * fov;
//             float distance_to_wall = 0;
//             bool hit_wall = false;

//             // Ray unit vector
//             float EyeX = sinf(ray_angle);
//             float EyeY = cosf(ray_angle);

//             // Raycasting: check for wall hit
//             while (!hit_wall && distance_to_wall < depth) {
//                 distance_to_wall += 0.1f;
//                 int testX = (int)(fPlayerX + EyeX * distance_to_wall);
//                 int testY = (int)(fPlayerY + EyeY * distance_to_wall);

//                 // Test if ray is out of bounds
//                 if (testX < 0 || testX >= map_width || testY < 0 || testY >= map_height) {
//                     hit_wall = true;
//                     distance_to_wall = depth;
//                 } else {
//                     // Ray is in bounds, check for a wall
//                     if (map[testY][testX] == '1') {
//                         hit_wall = true;
//                     }
//                 }
//             }

//             // Calculate the ceiling and floor positions
//             int ceiling = (int)(screen_height / 2.0f - screen_height / (float)distance_to_wall);
//             int floor = screen_height - ceiling;

//             // Draw the vertical slice (ceiling, wall, and floor)
//             for (int y = 0; y < screen_height; y++) {
//                 if (y < ceiling) {
//                     my_mlx_pixel_put(mlx, x, y, 0x87CEEB); // Ceiling color (light blue)
//                 } else if (y > ceiling && y <= floor) {
//                     // Ensure shading does not go out of bounds
//                     float shade = 1.0f - (distance_to_wall / depth); // Darken based on distance
//                     shade = fmaxf(0.0f, fminf(1.0f, shade)); // Clamp between 0 and 1
//                     int wall_color = (int)(shade * 255);
//                     my_mlx_pixel_put(mlx, x, y, (wall_color << 16) | (wall_color << 8) | wall_color); // Grayscale wall
//                 } else {
//                     my_mlx_pixel_put(mlx, x, y, 0x008000); // Floor color (green)
//                 }
//             }
//         }

//         // After rendering all the columns, put the image to the window
//         mlx_put_image_to_window(mlx->mlx_p, mlx->window, mlx->img.img, 0, 0);
//     }

//     // Start the mlx loop to handle input, etc.
//     mlx_loop(mlx->mlx_p);
// }

// int main(int argc, char **argv) {
//     t_mlx mlx;
//     t_data data;

//     // Start the game loop
//     game_loop(&data, &mlx);
//     return 0;
// }



-------------------------gpt plan------------------


Plan for Implementing cub3D

In this project, you are building a basic 3D maze using raycasting and the MiniLibX library to create a first-person view of the maze. Below is a step-by-step plan to guide you through the implementation, starting with your current code and expanding it to meet the project requirements.
1. Understanding the Core Components

The project can be divided into the following major components:

    Map Loading and Parsing: You already have a map loader, which is good. We'll enhance it to handle textures and colors properly.
    Raycasting: This is the heart of the project. The raycasting algorithm will simulate the 3D effect by casting rays and detecting wall intersections.
    Rendering: Once rays are cast, the results will be used to draw walls and textures based on the distance to the walls.
    Player Movement and Controls: You already have placeholders for handling inputs, but this will be expanded for full WASD movement and rotations.
    Error Handling and Edge Cases: Ensure error cases like incorrect file formatting or invalid maps are handled gracefully.

2. Plan Breakdown
I. Map Parsing and Setup

    Objective: Parse the .cub file and extract wall textures, floor/ceiling colors, and map layout.

Already Implemented:

    Reading the map and storing it as a 2D array (map2d).
    Handling some basic texture paths (NO, SO, WE, EA).

Next Steps:

    Parse and validate floor (F) and ceiling (C) colors. Store them as RGB values.
    Validate the map: ensure it's closed and surrounded by walls (1).
    Store playerâ€™s starting position and orientation from the map (N, S, E, W).

c

typedef struct s_color {
    int r;
    int g;
    int b;
} t_color;

typedef struct s_data {
    char    **map2d; // Already present
    char    *NO, *SO, *WE, *EA; // Texture paths (Already present)
    t_color floor_color;
    t_color ceiling_color;
    int     player_x, player_y;
    char    player_orientation;
} t_data;

Action:

    Finish parsing floor and ceiling colors, then validate map boundaries.

II. Raycasting

    Objective: Implement raycasting to create the first-person 3D effect.

Raycasting is the core algorithm. It casts rays from the player's position to detect walls and calculates the distance for each ray. The basic raycasting formula is:

    Cast a ray for each vertical slice of the screen (from the player's POV).
    Detect wall hits by checking intersections with the map grid.
    Calculate distance from player to the wall and determine how high to draw each wall slice.
    Apply textures to the walls based on the direction (north, south, east, west).

Key Equations:

    rayDirX = cos(player.angle)
    rayDirY = sin(player.angle)
    rayStepX and rayStepY determine how far the ray moves on each axis.

c

void raycasting(t_player *player, t_data *data, t_mlx *mlx) {
    int x = 0;
    while (x < S_W) {  // For each column on the screen
        double cameraX = 2 * x / (double)S_W - 1; // Camera plane
        double rayDirX = player->dirX + player->planeX * cameraX;
        double rayDirY = player->dirY + player->planeY * cameraX;

        // Raycasting calculations (DDA algorithm)
        int mapX = (int)player->player_x;
        int mapY = (int)player->player_y;

        // Calculate the distance and direction to the next wall...
        // Detect hit...
        // Render the correct texture slice...
        x++;
    }
}

Action:

    Implement the DDA (Digital Differential Analyzer) algorithm to cast rays, detect walls, and calculate distances.
    Use distance results to calculate wall height and display it accordingly.

III. Rendering Walls and Floor/Ceiling

    Objective: Draw walls, floors, and ceilings based on raycasting results.

For rendering:

    Wall: Height of each wall slice is inversely proportional to the distance to the wall (closer walls are taller, further ones are shorter).
    Floor/Ceiling: Use the colors defined in the .cub file and fill the remaining space at the top (ceiling) and bottom (floor).

Rendering Flow:

    Clear the screen.
    Cast rays for each vertical slice of the screen.
    For each ray:
        Compute the distance to the wall.
        Calculate the corresponding texture.
        Draw the wall slice using the correct texture.
    Draw floor and ceiling.

c

void draw_frame(t_data *data, t_player *player, t_mlx *mlx) {
    raycasting(player, data, mlx);  // Cast rays and draw walls
    // Fill the floor and ceiling
    fill_ceiling(data, mlx); // Using the ceiling color
    fill_floor(data, mlx); // Using the floor color
}

IV. Player Movement and Rotation

    Objective: Implement WASD controls for movement and left/right arrows for rotation.

Already Implemented:

    Basic input handling.

Next Steps:

    Use WASD to move the player. This will update the player's position (player_x, player_y) based on the direction they are facing.
    Use left and right arrow keys to rotate the playerâ€™s view (change player.angle).
    Implement collision detection: prevent the player from walking through walls.

c

void move_player(t_player *player, t_data *data) {
    if (player->u_d == 1) {  // Move forward
        player->player_x += cos(player->angle) * PLAYER_SPEED;
        player->player_y += sin(player->angle) * PLAYER_SPEED;
    }
    if (player->u_d == -1) {  // Move backward
        player->player_x -= cos(player->angle) * PLAYER_SPEED;
        player->player_y -= sin(player->angle) * PLAYER_SPEED;
    }
    // Similar logic for left/right
}

void rotate_player(t_player *player, int direction) {
    player->angle += direction * ROTATION_SPEED;
}

Action:

    Update player movement and rotation with smooth transitions.
    Handle collisions with walls.

V. Error Handling

    Objective: Ensure robust error handling for various scenarios.

Make sure to handle:

    Invalid map files: Maps not surrounded by walls, incorrect characters, or missing elements.
    Memory leaks: Make sure all allocated memory (textures, map arrays, etc.) is freed before exiting.
    Input validation: Ensure the .cub file is correctly formatted.

c

void validate_map(char **map) {
    // Check if the map is surrounded by walls, has valid characters
    // If any issue, exit with a proper error message
}

3. Bonus Features (Optional)

Once the mandatory part is perfect, you can implement some bonus features:

    Wall collisions: Already planned as part of player movement.
    Minimap system: Display a 2D minimap that shows the player's position and nearby walls.
    Doors: Add doors that can be opened and closed.
    Mouse-based view rotation: Allow the player to rotate the view by moving the mouse.

4. File Structure

Organize your files for readability and scalability:

scss

cub3D/
â”‚
â”œâ”€â”€ includes/
â”‚   â””â”€â”€ cub3d.h
â”‚
â”œâ”€â”€ srcs/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ read_map.c
â”‚   â”œâ”€â”€ raycasting.c
â”‚   â”œâ”€â”€ rendering.c
â”‚   â”œâ”€â”€ controls.c
â”‚   â”œâ”€â”€ error_handling.c
â”‚
â”œâ”€â”€ Makefile
â”œâ”€â”€ sources/
â”‚   â””â”€â”€ textures/ (your wall and floor textures)
â”‚
â””â”€â”€ maps/ (your .cub files)

5. Next Steps

    Finish parsing the .cub file (textures and colors).
    Implement raycasting to detect wall collisions and distances.
    Draw walls using the texture based on the player's direction.
    Handle player movement and rotation smoothly.
    Test and debug thoroughly to handle edge cases like incorrect map files or out-of-bounds movement.



----------------RATCASTING-------------------

    To implement raycasting in your project, you need to follow a well-structured approach. Raycasting is a technique that casts rays from the player's position, calculating where they intersect with walls in the 2D map, and then rendering those walls accordingly. Hereâ€™s a guide to help you get started:
Raycasting Overview

    The Player:
        The player has a position (player_x, player_y) and a direction (the angle they are facing).
        They also have a Field of View (FOV), typically 60 degrees.

    The Rays:
        For every vertical slice of your screen (each column of pixels), you will cast a ray from the playerâ€™s position.
        The ray will move in increments until it hits a wall.
        For each ray, calculate the distance from the player to the wall it hits, then use this distance to determine the height of the wall slice on screen.

    Rendering:
        Based on the distance of the wall from the player, you scale the wall height to create a 3D perspective.
        Walls closer to the player will be drawn taller, and walls further away will be shorter.

Step-by-Step Implementation
1. Define Constants and Player Setup

Add more constants to define the FOV, number of rays (based on screen width), and other necessary parameters.

In cub3d.h, add:

c

#define FOV_ANGLE (M_PI / 3) // 60 degrees field of view
#define NUM_RAYS S_W // One ray per vertical pixel column

2. Initialize Raycasting in the Game Loop

Youâ€™ll need to cast rays for every vertical slice of the screen. For this, you should add a function to cast rays and draw the resulting walls.
Update your game_loop function:

c

void game_loop(t_data *data, t_mlx *mlx)
{
    mlx->mlx_p = mlx_init();
    mlx->window = mlx_new_window(mlx->mlx_p, S_W, S_H, "Maze Runner");

    while (1) // Infinite game loop for the rendering
    {
        cast_rays(data, mlx); // Cast rays to render 3D scene
        mlx_key_hook(mlx->window, handle_input, mlx);
        mlx_loop(mlx->mlx_p);
    }
}

3. Casting Rays

Youâ€™ll need to create a function that casts rays from the player and calculates the distance to walls. This function should loop through every vertical slice of the screen and cast a ray for each one.
Add a cast_rays function:

c

void cast_rays(t_data *data, t_mlx *mlx)
{
    int x;
    double ray_angle;
    double ray_distance;

    ray_angle = data->player.angle - (FOV_ANGLE / 2); // Start from the leftmost angle of the FOV

    for (x = 0; x < NUM_RAYS; x++) 
    {
        ray_distance = cast_single_ray(ray_angle, data); // Calculate distance for this ray

        render_wall_slice(x, ray_distance, data, mlx); // Render the wall slice based on ray distance

        ray_angle += FOV_ANGLE / NUM_RAYS; // Increment angle for the next ray
    }
}

4. Casting a Single Ray

Now, you need to write a function to cast a single ray and find where it hits a wall. Use a "DDA" (Digital Differential Analyzer) algorithm to step through the map grid until the ray hits a wall.
Add a cast_single_ray function:

c

double cast_single_ray(double ray_angle, t_data *data)
{
    double x_step, y_step;
    double ray_x, ray_y;
    double distance_to_wall = 0;

    // Normalize the angle between 0 and 2*PI
    if (ray_angle < 0) ray_angle += 2 * M_PI;
    if (ray_angle > 2 * M_PI) ray_angle -= 2 * M_PI;

    // Calculate the direction in which the ray is going to step
    // X and Y step are based on angle
    x_step = cos(ray_angle);
    y_step = sin(ray_angle);

    ray_x = data->player.player_x;
    ray_y = data->player.player_y;

    while (1)
    {
        ray_x += x_step; // Move the ray forward in X direction
        ray_y += y_step; // Move the ray forward in Y direction

        // Check if the ray has hit a wall (1 in the map)
        if (data->map2d[(int)ray_y / TILE_SIZE][(int)ray_x / TILE_SIZE] == '1')
        {
            // Calculate distance to the wall
            distance_to_wall = sqrt(pow(ray_x - data->player.player_x, 2) + pow(ray_y - data->player.player_y, 2));
            break;
        }
    }

    return distance_to_wall;
}

5. Rendering the Wall Slices

Now, you need to render a wall slice based on the distance. The closer the wall, the taller the slice should be. You can use basic perspective calculations.
Add a render_wall_slice function:

c

void render_wall_slice(int x, double distance, t_data *data, t_mlx *mlx)
{
    int wall_height;
    int draw_start;
    int draw_end;

    // Correct the fish-eye effect by adjusting the distance with the player's angle
    distance = distance * cos(data->player.angle - ray_angle);

    // Calculate wall height based on distance
    wall_height = (TILE_SIZE / distance) * (S_W / 2);

    draw_start = (S_H / 2) - (wall_height / 2);
    draw_end = draw_start + wall_height;

    // Draw the wall slice (just a simple rectangle for now)
    for (int y = draw_start; y < draw_end; y++)
    {
        mlx_pixel_put(mlx->mlx_p, mlx->window, x, y, 0xFFFFFF); // White walls for now
    }
}

This will render simple white walls for each slice based on the raycast.
Next Steps

    Texturing Walls:
        Once the walls are rendered, the next step will be to apply the textures (e.g., data->NO, data->SO) to the walls. Youâ€™ll have to figure out the correct x-coordinate on the texture depending on where the ray hit the wall.

    Handle Key Input:
        You need to update the player's movement based on the keyboard (WASD and arrow keys).

    Optimization:
        Raycasting is a simple but potentially slow technique, so optimizing it for performance as you add more features will be important.

